// Generated by CoffeeScript 1.7.1
var HDFS, misc, rest;

module.exports = function(options) {
  return new HDFS(options);
};

module.exports.HDFS = HDFS;

HDFS = (function() {
  function HDFS(options) {
    var _base, _base1, _base2, _base3, _base4;
    this.options = options;
    if ((_base = this.options).protocol == null) {
      _base.protocol = 'http';
    }
    if ((_base1 = this.options).port == null) {
      _base1.port = 50070;
    }
    if ((_base2 = this.options).doas == null) {
      _base2.doas = null;
    }
    if ((_base3 = this.options).verbose == null) {
      _base3.verbose = false;
    }
    if ((_base4 = this.options).debug == null) {
      _base4.debug = false;
    }
    this.rest = new rest(this.options);
  }

  HDFS.prototype.write = function(path, data, overwrite, blocksize, replication, permission, buffersize, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['overwrite', 'blocksize', 'replication', 'permission', 'buffersize'];
    _ref1 = misc.args(arguments, (_ref = ['path', 'data']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'CREATE'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.put({
      path: options.path,
      query: query,
      code: [307, 201]
    }, (function(_this) {
      return function(err, res) {
        var h, headers, location, match, _j, _len1;
        if (err) {
          return callback(err);
        }
        if (res.code === 201) {
          return callback(null, res);
        }
        headers = res.header.split(/\r\n/);
        for (_j = 0, _len1 = headers.length; _j < _len1; _j++) {
          h = headers[_j];
          if (match = /^Location: (.*)$/.exec(h)) {
            location = match[1];
            break;
          }
        }
        return _this.rest.put({
          url: location,
          data: options.data
        }, function(err, res, body) {
          return callback(err, res);
        });
      };
    })(this));
  };

  HDFS.prototype.append = function(path, data, buffersize, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['buffersize'];
    _ref1 = misc.args(arguments, (_ref = ['path', 'data']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'APPEND'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.post({
      path: options.path,
      query: query,
      code: 307
    }, (function(_this) {
      return function(err, res) {
        var h, headers, location, match, _j, _len1;
        if (err) {
          return callback(err);
        }
        headers = res.header.split(/\r\n/);
        for (_j = 0, _len1 = headers.length; _j < _len1; _j++) {
          h = headers[_j];
          if (match = /^Location: (.*)$/.exec(h)) {
            location = match[1];
            break;
          }
        }
        return _this.rest.post({
          url: location,
          data: options.data
        }, function(err, res, body) {
          return callback(err);
        });
      };
    })(this));
  };

  HDFS.prototype.concat = function(path, sources, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['sources'];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    if (Array.isArray(options.sources)) {
      options.sources = options.sources.join(',');
    }
    query = {
      op: 'CONCAT'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.post({
      path: options.path,
      query: query
    }, (function(_this) {
      return function(err, res) {
        return callback(err, res);
      };
    })(this));
  };

  HDFS.prototype.read = function(path, offset, length, buffersize, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['offset', 'length', 'buffersize'];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'OPEN'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.get({
      path: options.path,
      query: query,
      follow: true,
      code: 200
    }, (function(_this) {
      return function(err, res, data) {
        if (err) {
          return callback(err);
        }
        return callback(null, data);
      };
    })(this));
  };

  HDFS.prototype.mkdir = function(path, permission, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['permission'];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'MKDIRS'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.put({
      path: options.path,
      query: query
    }, function(err, res, body) {
      if (err) {
        return callback(err);
      }
      body = JSON.parse(body);
      try {
        return callback(null, body);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    });
  };

  HDFS.prototype.symlink = function(path, destination, createParent, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['destination', 'createParent'];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'CREATESYMLINK'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    query.createParent = query.createParent ? 'true' : 'false';
    return this.rest.put({
      path: options.path,
      query: query
    }, function(err, res) {
      var body, e, _ref2, _ref3;
      try {
        if (res.body) {
          body = JSON.parse(res.body);
        }
        if (err && ((_ref2 = body.RemoteException) != null ? _ref2.message : void 0)) {
          err = Error((_ref3 = body.RemoteException) != null ? _ref3.message : void 0);
        }
        return callback(err, res);
      } catch (_error) {
        e = _error;
        return callback(err || e);
      }
    });
  };

  HDFS.prototype.rename = function(path, destination, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['destination'];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    if (!options.destination) {
      return callback(Error('Required argument "destination"'));
    }
    query = {
      op: 'RENAME'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.put({
      path: options.path,
      query: query
    }, function(err, res) {
      var body, e, _ref2, _ref3;
      try {
        if (res.body) {
          body = JSON.parse(res.body);
        }
        if (err && ((_ref2 = body.RemoteException) != null ? _ref2.message : void 0)) {
          err = Error((_ref3 = body.RemoteException) != null ? _ref3.message : void 0);
        }
        return callback(err, res);
      } catch (_error) {
        e = _error;
        return callback(err || e);
      }
    });
  };

  HDFS.prototype.remove = function(path, recursive, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['recursive'];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'DELETE'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.del({
      path: options.path,
      query: query
    }, function(err, res, body) {
      return callback(err);
    });
  };

  HDFS.prototype.stat = function(path, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = ['recursive'];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'GETFILESTATUS'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.get({
      path: options.path,
      query: query
    }, function(err, res, body) {
      if (err) {
        return callback(err);
      }
      try {
        return callback(null, JSON.parse(body));
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    });
  };

  HDFS.prototype.list = function(path, callback) {
    var k, options, query, query_keys, _i, _len, _ref, _ref1;
    query_keys = [];
    _ref1 = misc.args(arguments, (_ref = ['path']).concat.apply(_ref, query_keys)), options = _ref1[0], callback = _ref1[1];
    query = {
      op: 'LISTSTATUS'
    };
    for (_i = 0, _len = query_keys.length; _i < _len; _i++) {
      k = query_keys[_i];
      if (options[k]) {
        query[k] = options[k];
      }
    }
    return this.rest.get({
      path: options.path,
      query: query
    }, function(err, res, body) {
      if (err) {
        return callback(err);
      }
      try {
        return callback(null, JSON.parse(body));
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    });
  };

  return HDFS;

})();

misc = require('./misc');

rest = require('./rest');
